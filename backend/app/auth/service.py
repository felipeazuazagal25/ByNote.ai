from fastapi import Depends, HTTPException, Request
from fastapi_users import BaseUserManager, FastAPIUsers, UUIDIDMixin
from fastapi_users.authentication import (AuthenticationBackend,
                                          BearerTransport,
                                          JWTStrategy)
from app.models.auth import User
from app.dependencies import get_db, get_db_session
from fastapi_users.db import SQLAlchemyUserDatabase
from sqlalchemy.ext.asyncio import AsyncSession
import os
from typing import Optional, Tuple
from pathlib import Path
from dotenv import load_dotenv
from uuid import UUID
import logging
import random
import string
from typing import TYPE_CHECKING
from app.models import Project, Workspace

    

logger = logging.getLogger(__name__)

base_dir = Path(__file__).resolve().parent.parent
env_path = base_dir / '.env'
load_dotenv(dotenv_path=env_path)

SECRET = os.getenv("SECRET")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES"))

class UserManager(UUIDIDMixin, BaseUserManager[User, UUID]):
    reset_password_token_secret = os.getenv("SECRET")
    verification_token_secret = os.getenv("SECRET")
    verification_codes = {}  # Store verification codes


    # async def validate_user(self, user: User) -> None:
    #     if not user.is_verified:
    #         raise HTTPException(
    #             status_code=403,
    #             detail="User is not verified"
    #         )

    async def on_after_request_verify(self, user: User, token: str, request: Optional[Request] = None) -> dict:
        """Called after requesting verification token."""
        logger.info(f"Verification token requested for user: {user.email}, token: {token}")

        # The token is already generated by FastAPI-Users, we just need to return it
        return {"token": token}
        
    
    async def on_after_register(self, user: User, request: Optional[Request] = None):
        db = await get_db_session()  # Get the database session
        try:
            user_in_session = await db.get(User, user.id)
            await create_default_project(user_in_session, db)
            print(f"User {user.id} has registered.")
        finally:
            await db.close()

    async def on_after_forgot_password(self, user: User, token: str, request: Optional[Request] = None):
        print(f"User {user.id} has forgot their password.")
        
    async def on_after_verify(self, user: User, request: Optional[Request] = None):
        logger.info(f"User {user.id} has verified their email.")


bearer_transport = BearerTransport(tokenUrl="auth/jwt/login")

def get_jwt_strategy() -> JWTStrategy:
    return JWTStrategy(secret=SECRET, lifetime_seconds=ACCESS_TOKEN_EXPIRE_MINUTES * 60) 

auth_backend = AuthenticationBackend(
    name="jwt",
    transport=bearer_transport,
    get_strategy=get_jwt_strategy,
)

async def get_user_db(session: AsyncSession = Depends(get_db)):
    yield SQLAlchemyUserDatabase(session, User)

async def get_user_manager(user_db: SQLAlchemyUserDatabase = Depends(get_user_db)):
    yield UserManager(user_db)

# Update this line
fastapi_users = FastAPIUsers[User, UUID](get_user_manager, [auth_backend]) 

current_active_user = fastapi_users.current_user(active=True)


# async def verified_user(user: User = Depends(current_active_user)):
#     if not user.is_verified:
#         raise HTTPException(
#             status_code=403,
#             detail="User is not verified"
#         )
#     return user


async def create_default_workspace_and_project(user: User, db: AsyncSession) -> Tuple[Project, Workspace]:
    default_workspace_name = user.first_name + "'s Workspace"
    default_workspace_description = "This is the default workspace for " + user.first_name + "."
    db_workspace = Workspace(name=default_workspace_name, 
                             description=default_workspace_description, 
                             is_archived=False, 
                             is_shared=False, 
                             is_deleted=False, 
                             user_id=user.id)
    
    db_project = Project(name="Inbox", 
                         description="Inbox", 
                         is_archived=False, 
                         is_shared=False, 
                         ui_color="#000000", 
                         ui_icon="üîç", 
                         ui_theme="light", 
                         ui_font="sans-serif", 
                         user_id=user.id)
    db.add(db_project)
    await db.flush()  # This will generate the project ID
    
    # Update user with the new project ID
    user.default_project_id = db_project.id
    db.add(user)
    await db.commit()
    await db.refresh(db_project)
    await db.refresh(user)
    
    return db_project, db_workspace
        
        